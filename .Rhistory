# Call_Prc_Parity_Table<-cbind(FFT_Call_Parity_Prc, quantlib.bsm.call.prc)
# Call_Prc_Parity_Table
Put_Prc_Parity_Table<-cbind(put.prc.fft1, Put_Parity_Prc, quantlib.bsm.put.prc)
Put_Prc_Parity_Table
###########################################################################
# Pricing European Put Options Through Simulating Levy Processes
# Pseudocode implemented from Professor Liming Feng's Paper (pg. 08)
#
# Created by Joseph Loss on 1/01/2019
# Additional Recognition: Yuchen Duan (UIUC MSFE) and Daniel Liberman (UIC Finance)
#
# Fast-Fourier-Transform Algorithm
#
###########################################################################
# Inital Parameters  -------------------------------------------------------------
# taken from Feng, Table 1 pg. 23
chi.0 = -0.477
chi.K = 0
K = 22
# List Function (for initializing variable arrays) ------------------------
seqlist<-function(a, b, n)  {
list1 <- rep(0, n)
list1[1] = a
list1[n] = b
for (i in 2:(n-1)) {
list1[i] = (list1[n] - list1[i-1])*.326 + list1[i-1]
}
return(list1)
}
# Initialize Variable Arrays ----------------------------------------------
chi.list = seqlist(chi.0, chi.K, K+1)
Fhat.list = seq(0, 1, by=(1)/K)
eta = (Fhat.list[K+1] - Fhat.list[1]) / K
Fhat.list
# Brute-Force-Search function: chi ------------------------------------
# input = -0.1
brute_force_search.chi <- function(input) {
stock_prices.list = 0
for (variable in chi.list) {
if(variable > input)  {
return(stock_prices.list)
}
stock_prices.list = stock_prices.list+1
}
# Brute-Force-Search function: Fhat ------------------------------------
brute_force_search.Fhat <- function(input)  {
stock_prices.list = 0
for (variable in Fhat.list) {
if(variable > input)  {
return(stock_prices.list)
}
stock_prices.list = stock_prices.list+1
}
# Fhat Distribution Function ----------------------------------------------
# piecewise function for Fhat(x) taken from Feng, pg. 8 (Equation 3.12)
Fhat.distribution <- function(input)
{
stock_prices.list = 0
if(input < chi.list[1])                     # x < x0
{
stock_prices.list = 0
return(stock_prices.list)
}
else if(input >= chi.list[K+1])             # x > 0 xK
{
stock_prices.list = 1
return(stock_prices.list)
}
else                                        # (xk-1) <= chi
{
xk_1 =  brute_force_search.chi(input)     # xk = bs(input);
# Fhat[k-1] location:
stock_prices.list = Fhat.list[xk_1] + (Fhat.list[xk_1+1] - Fhat.list[xk_1])/eta * (input-chi.list[xk_1])
}
return(stock_prices.list)
}
# Inverse Transform Function ------------------------------------------------
# Approximation to F-1(U) using brute-force search
inverse_transform_method <- function()
{
U = runif(1,0,1)
xk_1 = brute_force_search.Fhat(U)
if(xk_1 < (K-1))              # function returns K-1
{
return(chi.list[xk_1+1] + (chi.list[xk_1+2] - chi.list[xk_1+1]) / (Fhat.list[xk_1+2] - Fhat.list[xk_1+1])*(U-Fhat.list[xk_1+1]))
}
else
{
return(0)
}
# Inverse Transform Method: Parameters -------------------------------
# taken from Feng, Section 6.1 pg. 22
Xt = inverse_transform_method()
s0 = 100;
strike = 100;
T = 0.5;
r = 0.03;
no_of_simulations = 256*10^3     # change number of MC iteriations here
# initialize price lists
stock_prices.list <- rep(0, no_of_simulations)
put_prices.list <- rep(0, no_of_simulations)
# Inverse Transform Method 1 -----------------------------------------------
# Calculate V using Section 5.4 of Feng's Paper (pg.19)
V <- rep(0, no_of_simulations)
for (j in 1:no_of_simulations)
{
V[j] = s0 * exp(-r*T) * max(0, strike/s0 - exp(inverse_transform_method()))
}
# Method 1 Result
put.prc.fft1 <- sum(V) / no_of_simulations
# plot the cdf
plot(chi.list)
# END  --------------------------------------------------------------------
# OPTIONAL: Inverse Transform Method 2 ----------------------------------------------
# uses default calculation for option price: V = e^(-r*T) * max(0, K - St)
for (j in 1:no_of_simulations)
{
Xt = inverse_transform_method()
stock_prices.list[j] = s0 * exp(Xt)
put_prices.list[j] = exp(-r * T) * max(0, strike - stock_prices.list[j])
}
# Method 2 Result
sum(stock_prices.list) / no_of_simulations
put.prc.fft2 <- sum(put_prices.list) / no_of_simulations
# Output both methods to table:
# note both methods should output very similar results:
values.table <- cbind(put.prc.fft1,put.prc.fft2)
values.table
###########################################################################
# Pricing European Put Options Through Simulated Levy Processes
# Pseudocode implemented from Professor Liming Feng's Paper (pg. 08)
#
# Created by Joseph Loss on 1/01/2019
# Co-developers: Yuchen Duan (UIUC MSFE) and Daniel Liberman (UIC Finance)
#
# Algorithm 2: Inverse-Transform Algorithm
#
###########################################################################
# Inital Parameters  -------------------------------------------------------------
# taken from Feng, Table 1 pg. 23
chi.0 = -0.477
chi.K = 0
K = 22
# List Function (for initializing variable arrays) ------------------------
seqlist<-function(a, b, n)  {
list1 <- rep(0, n)
list1[1] = a
list1[n] = b
for (i in 2:(n-1)) {
list1[i] = (list1[n] - list1[i-1])*.326 + list1[i-1]
}
return(list1)
}
# Initialize Variable Arrays ----------------------------------------------
chi.list = seqlist(chi.0, chi.K, K+1)
Fhat.list = seq(0, 1, by=(1)/K)
eta = (Fhat.list[K+1] - Fhat.list[1]) / K
Fhat.list
# Brute-Force-Search function: chi ------------------------------------
# input = -0.1
brute_force_search.chi <- function(input) {
stock_prices.list = 0
for (variable in chi.list) {
if(variable > input)  {
return(stock_prices.list)
}
stock_prices.list = stock_prices.list+1
}
# Brute-Force-Search function: Fhat ------------------------------------
brute_force_search.Fhat <- function(input)  {
stock_prices.list = 0
for (variable in Fhat.list) {
if(variable > input)  {
return(stock_prices.list)
}
stock_prices.list = stock_prices.list+1
}
#Binary Search
binary_search <- function(values, input, start, end){
mid = floor((start+end)/2)
if(values[mid]<= input && values[mid+1] >= input){
return(mid)
}
if(values[mid] > input){
end = mid
return(binary_search(values,input,start,end))
}
if(values[mid] < input){
start = mid
return(binary_search(values,input,start,end))
}
# Fhat Distribution Function ----------------------------------------------
# piecewise function for Fhat(x) taken from Feng, pg. 8 (Equation 3.12)
Fhat.distribution <- function(input)
{
stock_prices.list = 0
if(input < chi.list[1])                     # x < x0
{
stock_prices.list = 0
return(stock_prices.list)
}
else if(input >= chi.list[K+1])             # x > 0 xK
{
stock_prices.list = 1
return(stock_prices.list)
}
else                                        # (xk-1) <= chi
{
xk_1 =  binary_search(chi.list,input,1,length(chi.list))
#print(binary_search(chi.list,input,1,length(chi.list)))# xk = bs(input);
#xk_1 = brute_force_search.chi(input)
#print(brute_force_search.chi(input))
# Fhat[k-1] location:
stock_prices.list = Fhat.list[xk_1] + (Fhat.list[xk_1+1] - Fhat.list[xk_1])/eta * (input-chi.list[xk_1])
}
return(stock_prices.list)
}
# Inverse Transform Function ------------------------------------------------
# Approximation to F-1(U) using brute-force search
inverse_transform_method <- function()
{
U = runif(1,0,1)
xk_1 = binary_search(Fhat.list,U,1,length(Fhat.list))
#print(xk_1)
#xk_1 = brute_force_search.Fhat(U)
#print(xk_1)
if(xk_1 < (K-1))              # function returns K-1
{
return(chi.list[xk_1+1] + (chi.list[xk_1+2] - chi.list[xk_1+1]) / (Fhat.list[xk_1+2] - Fhat.list[xk_1+1])*(U-Fhat.list[xk_1+1]))
}
else
{
return(0)
}
# Inverse Transform Method: Parameters -------------------------------
# taken from Feng, Section 6.1 pg. 22
Xt = inverse_transform_method()
s0 = 100;
strike = 100;
T = 0.5;
r = 0.03;
no_of_simulations = 256*10^3     # change number of MC iteriations here
# initialize price lists
stock_prices.list <- rep(0, no_of_simulations)
put_prices.list <- rep(0, no_of_simulations)
# Inverse Transform Method 1 -----------------------------------------------
# Calculate V using Section 5.4 of Feng's Paper (pg.19)
V <- rep(0, no_of_simulations)
for (j in 1:no_of_simulations)
{
V[j] = s0 * exp(-r*T) * max(0, strike/s0 - exp(inverse_transform_method()))
}
# Method 1 Result
put.prc.fft1 <- sum(V) / no_of_simulations
plot(chi.list)
# END  --------------------------------------------------------------------
# OPTIONAL: Inverse Transform Method 2 ----------------------------------------------
# uses default calculation for option price: V = e^(-r*T) * max(0, K - St)
for (j in 1:no_of_simulations)
{
Xt = inverse_transform_method()
stock_prices.list[j] = s0 * exp(Xt)
put_prices.list[j] = exp(-r * T) * max(0, strike - stock_prices.list[j])
}
# Method 2 Result
sum(stock_prices.list) / no_of_simulations
put.prc.fft2 <- sum(put_prices.list) / no_of_simulations
# Output both methods to table:
values.table <- cbind(put.prc.fft1,put.prc.fft2)
values.table
###########################################################################
# Pricing European Put Options Through Simulated Levy Processes
# Pseudocode implemented from Professor Liming Feng's Paper (pg. 08)
#
# Created by Joseph Loss on 1/01/2019
# Co-developers: Yuchen Duan (UIUC MSFE) and Daniel Liberman (UIC Finance)
#
# Algorithm 2: Inverse-Transform Algorithm
#
###########################################################################
# Inital Parameters  -------------------------------------------------------------
# taken from Feng, Table 1 pg. 23
chi.0 = -0.477
chi.K = 0
K = 22
# List Function (for initializing variable arrays) ------------------------
seqlist<-function(a, b, n)  {
list1 <- rep(0, n)
list1[1] = a
list1[n] = b
for (i in 2:(n-1)) {
list1[i] = (list1[n] - list1[i-1])*.326 + list1[i-1]
}
return(list1)
}
# Initialize Variable Arrays ----------------------------------------------
chi.list = seqlist(chi.0, chi.K, K+1)
Fhat.list = seq(0, 1, by=(1)/K)
eta = (Fhat.list[K+1] - Fhat.list[1]) / K
Fhat.list
# Brute-Force-Search function: chi ------------------------------------
# input = -0.1
brute_force_search.chi <- function(input) {
stock_prices.list = 0
for (variable in chi.list) {
if(variable > input)  {
return(stock_prices.list)
}
stock_prices.list = stock_prices.list+1
}
# Brute-Force-Search function: Fhat ------------------------------------
brute_force_search.Fhat <- function(input)  {
stock_prices.list = 0
for (variable in Fhat.list) {
if(variable > input)  {
return(stock_prices.list)
}
stock_prices.list = stock_prices.list+1
}
#Binary Search
binary_search <- function(values, input, start, end){
mid = floor((start+end)/2)
if(values[mid]<= input && values[mid+1] >= input){
return(mid)
}
if(values[mid] > input){
end = mid
return(binary_search(values,input,start,end))
}
if(values[mid] < input){
start = mid
return(binary_search(values,input,start,end))
}
# Fhat Distribution Function ----------------------------------------------
# piecewise function for Fhat(x) taken from Feng, pg. 8 (Equation 3.12)
Fhat.distribution <- function(input)
{
stock_prices.list = 0
if(input < chi.list[1])                     # x < x0
{
stock_prices.list = 0
return(stock_prices.list)
}
else if(input >= chi.list[K+1])             # x > 0 xK
{
stock_prices.list = 1
return(stock_prices.list)
}
else                                        # (xk-1) <= chi
{
xk_1 =  binary_search(chi.list,input,1,length(chi.list))
#print(binary_search(chi.list,input,1,length(chi.list)))# xk = bs(input);
#xk_1 = brute_force_search.chi(input)
#print(brute_force_search.chi(input))
# Fhat[k-1] location:
stock_prices.list = Fhat.list[xk_1] + (Fhat.list[xk_1+1] - Fhat.list[xk_1])/eta * (input-chi.list[xk_1])
}
return(stock_prices.list)
}
# Inverse Transform Function ------------------------------------------------
# Approximation to F-1(U) using brute-force search
inverse_transform_method <- function()
{
U = runif(1,0,1)
xk_1 = binary_search(Fhat.list,U,1,length(Fhat.list))
#print(xk_1)
#xk_1 = brute_force_search.Fhat(U)
#print(xk_1)
if(xk_1 < (K-1))              # function returns K-1
{
return(chi.list[xk_1+1] + (chi.list[xk_1+2] - chi.list[xk_1+1]) / (Fhat.list[xk_1+2] - Fhat.list[xk_1+1])*(U-Fhat.list[xk_1+1]))
}
else
{
return(0)
}
# Inverse Transform Method: Parameters -------------------------------
# taken from Feng, Section 6.1 pg. 22
Xt = inverse_transform_method()
s0 = 100;
strike = 100;
T = 0.5;
r = 0.03;
no_of_simulations = 1024*10^3     # change number of MC iteriations here
# initialize price lists
stock_prices.list <- rep(0, no_of_simulations)
put_prices.list <- rep(0, no_of_simulations)
# Inverse Transform Method 1 -----------------------------------------------
# Calculate V using Section 5.4 of Feng's Paper (pg.19)
V <- rep(0, no_of_simulations)
for (j in 1:no_of_simulations)
{
V[j] = s0 * exp(-r*T) * max(0, strike/s0 - exp(inverse_transform_method()))
}
# Method 1 Result
put.prc.fft1 <- sum(V) / no_of_simulations
plot(chi.list)
# END  --------------------------------------------------------------------
# OPTIONAL: Inverse Transform Method 2 ----------------------------------------------
# uses default calculation for option price: V = e^(-r*T) * max(0, K - St)
for (j in 1:no_of_simulations)
{
Xt = inverse_transform_method()
stock_prices.list[j] = s0 * exp(Xt)
put_prices.list[j] = exp(-r * T) * max(0, strike - stock_prices.list[j])
}
# Method 2 Result
sum(stock_prices.list) / no_of_simulations
put.prc.fft2 <- sum(put_prices.list) / no_of_simulations
# Output both methods to table:
values.table <- cbind(put.prc.fft1,put.prc.fft2)
values.table
###########################################################################
# Pricing European Put Options Through Simulated Levy Processes
# Pseudocode implemented from Professor Liming Feng's Paper (pg. 17)
#
# Created by Joseph Loss on 12/17/2018
# Co-developers: Yuchen Duan (UIUC MSFE) and Daniel Liberman (UIC Finance)
#
# Algorithm 1: Simulating a Normal Inverse Gaussian process through a Brownian subordination
#
###########################################################################
# Input Parameters --------------------------------------------------------
# taken from Feng Paper pg. 22-23
alpha = 23;                             # corrected parameter, alpha=15 from paper is incorrect
beta = -5;
delta = 0.5;
r = 0.05;
q = 0.02;
s0 = 100;
K = s0;
T = 0.5;
N = 1.0;
no_of_simulations= 1024*10^3;       # change number of iterations here
# calculate mu using the formula given at the top of pg. 19
mu = r - q + delta*(sqrt(alpha^2 - (beta+1)^2) - sqrt(alpha^2 - beta^2));
# calculate gamma using the formula given in the Algorithm 1 pseudocode
gamma = sqrt(alpha^2 - beta^2)
stock_prc <- rep(0, no_of_simulations)       # create array of possible stock_prices (1 for each iteration)
put_prc <- rep(0, no_of_simulations)         # create array of possible put_prices (1 for each iteration)
call_prc <- rep(0, no_of_simulations)        # create array of possible call_prices (1 for each iteration)
euro_vanilla_put <- rep(0, no_of_simulations)
nigv <- rep(0, no_of_simulations)            # create NIG random vector
# Box-Muller Function Template --------------------------------------------
BoxMuller <- function() {
n = 2*N;
z = numeric(n);
u1 = runif(n/2,0,1);
u2 = runif(n/2,0,1)
z1 = sqrt(-2*log(u1)) * cos(2*pi*u2)      # half of normal variates
z2 = sqrt(-2*log(u1)) * sin(2*pi*u2)      # other half
z[seq(1, n, by=2)] = z1                   # interleave
z[seq(2, n, by=2)] = z2                   # two halves
return(z1)                                # return half
}
# Algorithm 1: Normal Inverse Gaussian, Monte-Carlo Simulation --------------------------------------------
for (j in 1:no_of_simulations)
{
# Step 1: Generate G1 and compute zeta --------------------------------------------------
G1 <- rnorm(1,0,1)           # generate standard normal random variable G1
Z <- (G1^2)/gamma           # compute Z
zeta <- rep(0, N)
for (i in 1:N)
{
zeta[i] = (1/gamma)*((delta*i) + (0.5*Z[i]) - sqrt((delta*i*Z[i]) + (Z[i]^2)/4))
}
# Step 2: Generate uniform random variable U on (0,1) -----------------------------------
Uniform <- function()       # function to generate uniform r.v. using Algorithm 1, Step 2, on pg. 17
{
U = runif(N,0,1)
zt <- rep(0,N)
for (i in 1:N)  {
if (U[i] < (delta)/(delta+gamma*zeta[i])) {
zt[i] = zeta[i]
} else  {
zt[i] = (delta^2) / (gamma^2 * zeta[i])
}
return(zt)
}
zt = Uniform()          # generate zt using uniform function above
# Step 3: Generate StdNorm variable G2 -------------------------------------------------
G2 <- rnorm(1,0,1)
St <- rep(0,N)        # create empty vector for St
Xt <- rep(0,N)        # create empty vector for Xt
for (i in 1:N)
{
Xt[i] = mu*i + beta*zt[i] + sqrt(zt[i])*G2[i]     # compute Xt = mu*t + beta*zt + sqrt(zt)*G2
St[i] = s0 * exp(Xt[i])                         # from pg 16. compute St = S0 * e^(Xt)
}
stock_prc[j] = St[N]                                  # reassign variable, ie St = ST (stock value at maturity)
put_prc[j] = exp(-r*T) * max(0, K - stock_prc[j])     # compute put price at maturity
call_prc[j] = exp(-r*T) * max(0, stock_prc[j] - K)    # compute call price at maturity
nigv[j] = Xt[N]
# Section 5.4, pg.19: European Vanilla Options -------------------------------------------
# here, we use calculate the option value "V" using the formula given in Section 5.4.
# note that the resulting output is identical
# to the result we generated through St = S0 * e^(Xt) above.
euro_vanilla_put[j] = s0 * exp(-r * T) * max(0, K/s0 - exp(log(stock_prc[j] / s0)))
}
# END MonteCarlo Simulation --------------------------------------------------------------
# ----------------------------------------------------------------------------------------
# Average the computed prices: -----------------------------------------------------------
"NIG Stock Price (t=T)"
sum(stock_prc) / no_of_simulations
NIG_Put_Prc <- sum(put_prc) / no_of_simulations
"NIG Put Value: "
NIG_Put_Prc
euro_vanilla_put.value <- sum(euro_vanilla_put) / no_of_simulations
"European Vanilla Put Value: "
euro_vanilla_put.value
values.table <- cbind(NIG_Put_Prc,euro_vanilla_put.value)
values.table
